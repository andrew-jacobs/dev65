		.TITLE	SWTBUG
;      VERSION 1.00

;****************************************************
;*REPLACEMENT FOR MIKBUG ROM
;*FOR SWTPC 6800 COMPUTER SYSTEM
;*COPYRIGHT 1977
;*SOUTHWEST TECHNICAL PROD. CORP.
;*AUGUST, 1977
;****************************************************

		.BSS
		.ORG	$A000
		
IRQ 		.SPACE	2		; IRQ POINTER
BEGA 		.SPACE	2		; BEGINNING ADDR PNCH
ENDA 		.SPACE	2		; ENDING ADDR PNCH
NMI 		.SPACE	2		; NMI INTERRUPT VECTOR
SP 		.SPACE	1		; S HIGH
		.SPACE	1		; S LOW
PORADD 		.SPACE	2		; PORT ADDRESS
PORECH 		.SPACE	1		; ECHO ON/OFF FLAG
XHI 		.SPACE	1		; XREG HIGH
XLOW 		.SPACE	1		; XREG LOW
CKSM 		.SPACE	1		; CHECKSUM
XTEMP 		.SPACE	2		; X-REG TEMP STGE
SWIJMP 		.SPACE	2		; SWI JUMP VECTOR
TW 		.EQU	$A044		; TEMPORARY STORAGE
TEMP 		.EQU	$A046		; TEMPORARY STORAGE
BYTECT 		.EQU	$A047		; BYTECT AND MCONT TEMP.
CTLPOR 		.EQU	$8004		; CONTROL PORT ADDRESS
PROM 		.EQU	$C000		; JUMP TO PROM ADDRESS
BKPT 		.SPACE	2		; BREAKPOINT ADDRESS
BKLST 		.SPACE	1		; BREAKPOINT DATA

		.ORG 	$A042
STACK 		.SPACE 	1		; SWTBUG STACK

		.ORG	$E000

; I/O INTERRUPT SEQUENCE
IRQV		LDX	IRQ
		JMP	0,X

; JUMP TO USER PROGRAM
JUMP 		BSR	BADDR
		JMP	0,X

CURSOR 		.BYTE	$10,$16,4	; CT-1024 CURSOR CONTROL

; ASCII LOADING ROUTINE
LOAD		JSR	RDON		; READER ON, DIS ECHO, GET P#
LOAD3		BSR	INCH
		CMP A	#'S'
		BNE	LOAD3		; 1ST CHAR NOT S
		BSR 	INCH		; READ CHAR
		CMP A 	#'9'
		BEQ 	LOAD21
		CMP A 	#'1'
		BNE	LOAD3		; 2ND CHAR NOT 1
		CLR 	CKSM		; ZERO CHECKSUM
		BSR 	BYTE		; READ BYTE
		SUB A 	#2
		STA A 	BYTECT		; BYTE COUNT
; BUILD ADDRESS
		BSR 	BADDR
; STORE DATA
LOAD11 		BSR 	BYTE
		DEC 	BYTECT
		BEQ 	LOAD15		; ZERO BYTE COUNT
		STA A 	0,X 		; STORE DATA
		CMP A 	0,X		; DATA STORED?
		BNE 	LOAD19
		INX
		BRA 	LOAD11
LOAD15 		INC 	CKSM
		BEQ 	LOAD3
LOAD19 		LDA A 	#'?'
		BSR 	OUTCH
LOAD21 		JMP 	RDOFF1

; BUILD ADDRESS
BADDR 		BSR 	BYTE		; READ 2 FRAMES
		STA A 	XHI
		BSR 	BYTE
		STA A 	XLOW
		LDX 	XHI		; LOAD IXR WITH NUMBER
		RTS

; INPUT BYTE (TWO FRAMES)
BYTE 		BSR 	INHEX		; GET HEX CHAR
BYTE1 		ASL A
		ASL A
		ASL A
		ASL A
		TAB
		BSR 	INHEX
		ABA
		TAB
		ADD B 	CKSM
		STA B 	CKSM
		RTS

OUTHL 		LSR A 			; OUT HEX LEFT BCD DIGIT
		LSR A
		LSR A
		LSR A
OUTHR 		AND A 	#$F		; OUT HEX RIGHT BCD DIGIT
		ADD A 	#$30
		CMP A 	#$39
		BLS 	OUTCH
		ADD A 	#$7

; OUTPUT ONE CHAR
OUTCH 		JMP 	OUTEEE
INCH 		JMP 	INEEE

; PRINT DATA POINTED TO BY X REG
PDATA2 		BSR 	OUTCH
		INX
PDATA1 		LDA A 	0,X
		CMP A 	#4
		BNE 	PDATA2
		RTS			; STOP ON HEX 04

C1 		JMP 	SWTCTL

; MEMORY EXAMINE AND CHANGE
CHANGE 		BSR 	BADDR
CHA51 		LDX 	#MCL
		BSR 	PDATA1		; C/R L/F
		LDX 	#XHI
		BSR 	OUT4HS		; PRINT ADDRESS
		LDX 	XHI
		BSR 	OUT2HS		; PRINT OLD DATA
		BSR 	OUTS		; OUTPUT SPACE
ANOTH 		BSR 	INCH		; INPUT CHAR
		CMP A 	#$20
		BEQ 	ANOTH
		CMP A 	#$D
		BEQ 	C1
		CMP A 	#'^'		; UP ARROW?
		BRA 	AL3		; BRANCH FOR ADJUSTMENT
		NOP

; INPUT HEX CHARACTER
INHEX 		BSR 	INCH
INHEX1 		SUB A 	#$30
		BMI 	C3
		CMP A 	#$9
		BLE 	IN1HG
		CMP A 	#$11
		BMI 	C3		; NOT HEX
		CMP A 	#$16
		BGT 	C3		; NOT HEX
		SUB A 	#7
IN1HG 		RTS

OUT2H 		LDA A 	0,X		; OUTPUT 2 HEX CHAR
OUT2HA 		BSR 	OUTHL		; OUT LEFT HEX CHAR
		LDA A 	0,X
		INX
		BRA 	OUTHR		; OUTPUT RIGHT HEX CHAR

OUT4HS 		BSR 	OUT2H		; OUTPUT 4 HEX CHAR + SPACE
OUT2HS 		BSR 	OUT2H		; OUTPUT 2 HEX CHAR + SPACE

OUTS 		LDA A 	#$20		; SPACE
		BRA 	OUTCH		; (BSR & TRS)

; ENTER POWER ON SEQUENCE
START 		LDS 	#STACK
		BRA 	AL1		; BRANCH FOR ADDRESS COMPATIBIL

;********************************************
; PART OF MEMORY EXAMINE AND CHANGE
AL3 		BNE 	SK1
		DEX
		DEX
		STX 	XHI
		BRA 	CHA51
SK1 		STX 	XHI
		BRA 	AL4

EOE3 		BRA 	CONTRL		; BRANCH FOR MIKBUG EQUIV. CONT

AL4 		CMP A 	#$30
		BCS 	CHA51
		CMP A 	#$46
		BHI 	CHA51
		BSR 	INHEX1
		JSR 	BYTE1
		DEX
		STA A 	0,X CHANGE MEMORY
		CMP A 	0,X
		BEQ 	CHA51 DID CHANGE
		JMP 	LOAD19 DIDN'T CHANGE
C3 		LDS 	SP
		BRA 	SWTCTL
;**************************************************

; CONTINUE POWER UP SEQUENCE
AL1 		STS 	SP		; INIT TARGET STACK PTR.
		LDA A 	#$FF
		JSR 	SWISET
; CONFIGURE FOR PIA AND SEE IF OK
		LDX 	#CTLPOR
		JSR 	PIAINI		; INIT PIA
		LDA A 	0,X
		CMP A 	2,X
		BRA 	AL2

		BRA 	PRINT		; BRA FOR BILOAD

AL2 		BNE 	CONTRL

; INITIALIZE AS ACIA
		LDA A 	#3		; ACIA MASTER RESET
		STA A 	0,X
		LDA A 	#$11
		STA A 	0,X
		BRA 	CONTRL

; ENTER FROM SOFTWARE INTERRUPT
SF0 		NOP
SFE1 		STS 	SP		; SAVE TARGETS STACK POINTER
; DECREMENT P COUNTER
		TSX
		TST 	6,X
		BNE 	*+4
		DEC 	5,X
		DEC 	6,X
; PRINT CONTENTS OF STACK.
PRINT 		LDX 	#MCL
		JSR 	PDATA1
		LDX 	SP
		INX
		BSR 	OUT2HS		; COND CODES
		BSR 	OUT2HS		; ACC B
		BSR 	OUT2HS		; ACC A
		BSR 	OUT4HS		; IXR
		BSR 	OUT4HS		; PGM COUNTER
		LDX 	#SP
		JSR 	OUT4HS		; STACK POINTER
SWTCTL 		LDX 	SWIJMP
		CPX 	#SF0
		BEQ 	CONTR1

CONTRL 		LDS 	#STACK		; SET CONTRL STACK POINTER
		LDX	#CTLPOR		; RESET TO CONTROL PORT
		STX 	PORADD
		CLR 	PORECH		; TURN ECHO ON
		BSR 	SAVGET		; GET PORT # AND TYPE
		BEQ 	POF1
		JSR 	PIAECH		; SET PIA ECHO ON IF MP-C INTER
POF1 		JSR 	PNCHOF		; TURN PUNCH OFF
		JSR 	RDOFF		; TURN READER OFF
CONTR1 		LDX 	#MCLOFF
		JSR 	PDATA1		; PRINT DATA STRING
		BSR 	INEEE		; READ COMMAND CHARACTER

; COMMAND LOOKUP ROUTINE
LOOK 		LDX 	#TABLE
OVER 		CMP A 	0,X
		BNE 	SK3
		JSR 	OUTS		; SKIP SPACE
		LDX 	1,X
		JMP 	0,X
SK3 		INX
		INX
		INX
		CPX 	#TABEND+3
		BNE 	OVER
SWTL1 		BRA 	SWTCTL

; SOFTWARE INTERRUPT ENTRY POINT
SFE 		LDX 	SWIJMP		; JUMP TO VECTORED SOFTWARE INT
		JMP 	0,X

S9 		.BYTE	'S','9',4	; END OF TAPE

;***************************************************
MTAPE1		.BYTE 	$D,$A,$15,0,0,0,'S','1',4 ; PUNCH FORMAT

MCLOFF		.BYTE	$13		; READER OFF
MCL		.BYTE	$D,$A,$15,0,0,0,'$',4

EIA5		BRA 	BILD		; BINARY LOADER INPUT
;***************************************************


; NMI SEQUENCE
NMIV 		LDX 	NMI		; GET NMI VECTOR
		JMP 	0,X

INEEE	 	BRA 	INEEE1

; BYTE SEARCH ROUTINE
SEARCH 		JSR 	BADDR		; GET TOP ADDRESS
		STX 	ENDA
		JSR 	BADDR		; GET BOTTOM ADDRESS
		JSR 	BYTE		; GET BYTE TO SEARCH FOR
		TAB
OVE 		LDA A 	0,X
		STX 	XHI
		CBA
		BEQ 	PNT
		BRA 	INCR1
PNT 		LDX 	#MCL
		JSR 	PDATA1
		LDX 	#XHI
		BRA 	SKP0
;***************************************************

; GO TO USER PROGRAM ROUTINE
GOTO 		RTI
OUTEEE 		BRA 	OUTEE1



; SAVE IXR AND LOAD IXR WITH CORRECT
; PORT NUMBER AND TEST FOR TYPE
SAVGET 		STX 	XTEMP		; STORE INDEX REGISTER
GETPT1 		LDX 	PORADD
ISACIA 		PSH B
		LDA B 	1,X
		CMP B 	3,X
		PUL B
		RTS
;***************************************************

; CONTINUATION OF SEARCH ROUTINE
SKP0 		JSR 	OUT4HS
		LDX 	XHI
INCR1 		CPX 	ENDA
		BEQ 	SWTL1
		INX
		BRA 	OVE

INEEE1 		BSR 	INCH8		; INPUT 8 BIT CHARACTER
		AND A 	#%01111111	; GET RID OF PARITY BIT
		RTS

BILD 		INS 			; FIX UP STACK WHEN USING
		INS 			; BINARY LOADER ON SWTPC TAPES
		INS

; INPUT ONE CHAR INTO ACC B
INCH8 		PSH B 			; SAVE ACC B
		BSR 	SAVGET		; SAVE IXR, GET PORT# AND TYPE
		BNE 	IN1		; INPUT FROM PIA IF NOT
		LDA A 	#$15		; RECONFIG FOR 8 BIT, 1 SB
		STA A 	0,X
ACIAIN 		LDA A 	0,X
		ASR A
		BCC 	ACIAIN		; NOT READY
		LDA A 	1,X		; LOAD CHAR
		LDA B 	PORECH
		BEQ 	ACIOUT		; ECHO
		BRA 	RES		; DON'T ECHO

; OUTPUT ONE CHARACTER
OUTEE1 		PSH B			; SAVE ACC B
		BSR 	SAVGET
		BNE 	IOUT

ACIOUT 		LDA B 	#$11
		STA B 	0,X
ACIOU1 		LDA B 	0,X
		ASR B
		ASR B
		BCC 	ACIOU1		; ACIA NOT READY
		STA A 	1,X		; OUTPUT CHARACTER
RES 		PUL B			; RESTORE ACC B
		LDX 	XTEMP
		RTS

; PIA INPUT ROUTINE
IN1 		LDA A 	0,X		; LOOK FOR START BIT
		BMI 	IN1
		BSR 	DDL		; DELAY HALF BIT TIME
		LDA B 	#4		; SET DEL FOR FULL BIT TIME
		STA B	2,X
		ASL B			; SET UP CNTR WITH 8
IN3 		BSR 	DEL		; WAIT ONE CHAR TIME
		SEC
		ROL 	0,X
		ROR A
		DEC B
		BNE 	IN3
		BSR 	DEL		; WAIT FOR STOP BIT
		LDA B 	PORECH		; IS ECHO DESIRED?
		BEQ 	IOUT2		; ECHO
		BRA 	RES		; RESTORE IXR,ACCB
; PIA OUTPUT ROUTINE
IOUT 		BSR 	DDL1		; DELAY ONE HALF BIT TIME
		LDA B 	#$A		; SET UP COUNTER
		DEC 	0,X		; SET START BIT
		BSR 	DE		; START TIMER
OUT1 		BSR 	DEL		; DELAY ONE BIT TIME
		STA A 	0,X		; PUT OUT ONE DATA BIT
		SEC
		ROR A			; SHIFT IN NEXT BIT
		DEC B			; DECREMENT COUNTER
		BNE 	OUT1		; TEST FOR 0
IOUT2 		LDA B	2,X		; TEST FOR STOP BITS
		ASL B			; SHIFT BIT TO SIGN
		BPL 	RES		; BRA FOR 1 STOP BIT
		BSR 	DEL		; DELAY FOR STOP BITS
		BRA 	RES
DEL 		TST 	2,X		; IS TIME UP
		BPL 	DEL
DE 		INC 	2,X		; RESET TIMER
		DEC 	2,X
		RTS

DDL 		CLR 	2,X		; HALF BIT DELAY
DDL1 		BSR 	DE
		BRA 	DEL


; OPTIONAL PORT ROUTINE
OPTL 		BSR 	INEEE1
		TAB
		CLR 	PORADD+1	; SET I/O ADDRESS FOR $8000
		LDX 	PORADD
		BSR 	PIAINI		; INITIALIZE PIA
		BSR 	PIAECH		; SET ECHO
		LDX 	#TABLE1		; P, L OR E
		TBA
		JMP 	OVER		; LOOK AT TABLE FOR E, L OR P

PIAECH 		LDA A 	#$34		; SET DDR
		STA A 	3,X
		STA A 	2,X
NOOPT 		RTS

; PIA INITIALIZATION ROUTINE
PIAINI 		INC 	0,X		; SET DDR
		LDA A 	#$7
		STA A 	1,X
		INC 	0,X
		STA A 	2,X
		RTS

; MINIFLOPPY DISK BOOT
DISK 		CLR 	$8014
		BSR 	DELAY
		LDA B 	#$0B
		BSR 	RETT2
LOOP1 		LDA B 	4,X
		BIT B 	#1
		BNE 	LOOP1
		CLR 	6,X
		BSR 	RETURN
		LDA B 	#$9C
		BSR 	RETT2
		LDX 	#$2400
LOOP2 		BIT B 	#2
		BEQ 	LOOP3
		LDA A 	$801B
		STA A 	0,X
		INX
LOOP3 		LDA B 	$8018
		BIT B 	#1
		BNE 	LOOP2
		JMP 	$2400
RETT2 		STA B 	4,X
RETURN 		BSR 	RETT1
RETT1 		RTS

; GENERAL PURPOSE DELAY LOOP
DELAY 		LDX 	#$FFFF
DELAY1 		DEX
		CPX 	#$8014		; STOP AT 8014
DUM 		BNE 	DELAY1
		RTS


; CLRAR SCREEN FOR CT-1024 TYPE TERMINALS
CLEAR 		LDX 	#CURSOR
		JSR 	PDATA1
		BSR 	DELAY1		; DELAY
RDOFF1 		JSR 	RDOFF
		BRA 	C4

; BREAKPOINT ENTERING ROUTINE
BREAK 		LDX 	#SF0
		CPX 	SWIJMP		; BREAKPOINTS ALREADY IN USE?
		BEQ 	INUSE
		INX
BREAK0 		BSR 	STO1
		JSR 	BADDR
		STX 	BKPT
		LDA A 	0,X
		STA A 	BKLST
		LDA A 	#$3F
		STA A 	0,X
		LDX 	#SF0
		BSR 	STO1
		JMP 	CONTR1
INUSE 		LDX 	BKPT
		LDA A  	BKLST
		STA A 	0,X
		LDX 	#SFE1
		BRA 	BREAK0

SWISET 		STA A 	STACK+1		; FIX POWER UP INTERRUPT
		LDX 	SWIJMP
		CPX 	#SF0
		BEQ 	STORTN
STO 		LDX 	#SFE1
STO1 		STX 	SWIJMP
STORTN 		RTS

PUNCH1 		BSR 	PUNCH
		BRA 	POFC4

; FORMAT END OF TAPE WITH PGM. CTR. AND S9
PNCHS9 		LDX 	#$A049
		STX 	ENDA
		DEX
		BSR 	PUNCH2
		LDX 	#S9
PDAT 		JSR 	PDATA1
POFC4 		BSR 	PNCHOF
		BSR 	DELAY
C4 		JMP 	CONTRL

RDON 		COM 	PORECH		; DISABLE ECHO FOR ACIA
		LDA A 	#$11		; RON CHAR.
		LDA B 	#$20		; STROBE CHAR
		BSR 	STROBE
		JSR 	ISACIA		; CHECK TO SEE IF PIA
		BEQ 	RTNN
		LDA A 	#$3C		; DISABLE PIA ECHO IF PIA
		STA A 	3,X
RTNN 		RTS

RDOFF 		LDA A 	#$13		; TURN READER OFF
		LDA B 	#$10
		BRA 	STROBE

PNCHON 		LDA A 	#$12
		LDA B 	#4
		BRA 	STROBE

PNCHOF 		LDA A 	#$14
		LDA B 	#$8

; PIA STROBING ROUTINE FOR PUNCH/READ ON/OFF
STROBE 		JSR 	OUTCH
		JSR 	GETPT1
		BEQ 	RTN1
		LDA A 	#2
		ORA B 	#1
		BSR 	STR2
		BSR 	STR1
		LDA A 	#2
		LDA B 	#1
		STA B 	0,X
		BSR 	STR2
STR1 		LDA A 	#6
STR2 		STA A 	1,X
		STA B 	0,X
RTN1 		RTS

; PUNCH FROM BEGINNING ADDRESS (BEGA) THRU
; ENDING ADDRESS (ENDA)
PUNCH 		LDX 	BEGA
PUNCH2 		STX 	TW
		BSR 	PNCHON
PUN11 		LDA A 	ENDA+1
		SUB A 	TW+1
		LDA B 	ENDA
		SBC B 	TW
		BNE 	PUN22
		CMP A 	#16
		BCS 	PUN23
PUN22 		LDA A 	#15
PUN23 		ADD A 	#4
		STA A 	BYTECT
		SUB A 	#3
		STA A 	TEMP
; PUNCH C/R L/F NULLS S1
		LDX 	#MTAPE1
		JSR 	PDATA1
		CLR B
; PUNCH FRAME COUNT
		LDX 	#BYTECT
		BSR 	PUNT2		; PUNCH 2 HEX CHARACTERS
; PUNCH ADDRESS
		LDX 	#TW
		BSR 	PUNT2
		BSR 	PUNT2
; PUNCH DATA
		LDX 	TW
PUN32 		BSR 	PUNT2		; PUNCH ONE BYTE
		DEC 	TEMP
		BNE 	PUN32
		STX 	TW
		COM B
		PSH B
		TSX
		BSR 	PUNT2		; PUNCH CHECKSUM
		PUL B 			; RESTORE STACK
		LDX 	TW
		DEX
		CPX 	ENDA
		BNE 	PUN11
RTN5 		RTS

; PUNCH 2 HEX CHAR, UPDATE CHECKSUM
PUNT2 		ADD B 	0,X
		JMP 	OUT2H		; OUTPUT 2 HEX CHAR AND RTS

; COMMAND TABLE
TABLE 		.BYTE	'G'		; GOTO
		.WORD 	GOTO
		.BYTE 	'Z'		; GOTO PROM
		.WORD 	PROM
		.BYTE 	'M'		; MEMORY EXAM AND CHANGE
		.WORD 	CHANGE
		.BYTE 	'F'		; BYTE SEARCH
		.WORD 	SEARCH
		.BYTE 	'R'		; REGISTER DUMP
		.WORD 	PRINT
		.BYTE 	'J'		; JUMP
		.WORD 	JUMP
		.BYTE 	'C'		; CLEAR SCREEN
		.WORD 	CLEAR
		.BYTE 	'D'		; DISK BOOT
		.WORD 	DISK
		.BYTE 	'B'		; BREAKPOINT		
		.WORD 	BREAK
		.BYTE 	'O'		; OPTIONAL PORT
		.WORD 	OPTL
TABLE1 		.BYTE 	'P'		; ASCII PUNCH
		.WORD 	PUNCH1
		.BYTE 	'L'		; ASCII LOAD
		.WORD 	LOAD
TABEND 		.BYTE 	'E'		; END OF TAPE
		.WORD 	PNCHS9

		.ORG	$FFF8
		.WORD	IRQV		; IRQ VECTOR
		.WORD	SFE		; SOFTWARE INTERRUPT
		.WORD	NMIV		; NMI VECTOR
		.WORD	START		; RESTART VECTOR

		.ORG	$A048
		.WORD	START
		.END